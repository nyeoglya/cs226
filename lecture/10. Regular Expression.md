- language $L$: set of strings
- automata: machine that accepts the strings in $L$
- grammar $G$: set of rule that generates strings in $L$
- grammar에 regular expression이 사용된다.
- regular expression에 대응되는 automata를 finite automata라고 부른다.
- finite automata에서는 여러 개의 state가 존재한다. 그 중 하나는 final state임.
- ex: $L=\{a, aa, aaa, ...\}$가 있다고 하자. RE는 $a^+$이고, FA는 적당히 생각가능.
- regular expression은 regular language에 대응된다.
	- literal a
	- concatenation $xy$
	- union $x|y$
	- kleene star $x*$(0 혹은 더 많은 반복을 허용함)
	- $\epsilon$ = empty string
- 전화번호를 입력한다고 하자. 각 automata의 edge가 0부터 9까지의 숫자를 갖는다. 이걸 전부 다 쓰는 건 공간 낭비이기 때문에 $\text{digit}=0|1|\cdots|9$로 정의한 후에, 모든 edge에 digit이라고 쓴다. 파이썬에서는 이를 `[0-9]`라고 쓴다.
- python string method를 써도 뭔가를 할 수 있다. 그러나, 이건 너무 간단한 것 밖에 못함. 그래서 regex가 필요한 거임.
- regex에는 다음의 4가지 문법이 있다. 위쪽일 수록 우선순위가 높다.
	1. grouping: ()
	2. closure: *
	3. concat.: adj.
	4. or: |
- meta character들
	- `.`: newline 제외 any char
	- `*`: zero or more
	- `+`: one or more
	- `?`: zero or one
	- `^`: start of line
	- `$`: end of line
	- `\`: escape next char
- basic classes
	- `[abc]`: a,b,c 중 아무거나
	- `[a-z]`: lowercase
	- `[A-Z]`: uppercase
	- `[0-9]`: digit
	- `[^abc]`: not a,b,c
	- predefined:
		- \d, \D: digit/non-digit
		- \w, \W: word/non-word
		- \s, \S: whitespace/non-space
- quantifiers: 정확한 수를 정할 수 있음
	- `{n}`: n개
	- `{n,}`: n 혹은 더
	- `{n,m}`: n과 m 사이
	- 예시: `[0-9]{3}-[0-9]{4}-[0-9]{4}`는 전화번호임.
	- 예시2: `[A-Za-z0-9]+@[A-Za-z0-9]+\.(com|edu)`
- greedy(`*`): 가능한 한 긴 span을 잡는다.
- non-greedy(`*?`): 짧은 span을 찾는다.
	- 예시: `<div>a</div> and <div>b</div>`
	- `<div>*</div>`는 전체를 잡지만, `<div>*?</div>`는 각각을 잡는다.
- python re API: regex를 찾아서 작업을 수행하는데 사용한다.
	- re.compile: 컴파일. 주어진 regex에 대해, 컴파일은 내부적으로 finite automata를 만드는 것임. 한번만 만들고, 그걸 재사용해서 성능을 높인다.
	- re.search/re.match: 찾기
- pandas에서의 비슷한 역할을 찾아줄 수 있음.
- capture group: 각각을 사용할 수 있는 tuple로 잡는다. ==소괄호 ()로 쳐져있는게 하나의 group인 듯? <- 확인하기==
- re.match: 이 함수의 반환값이 group이다.
- `?P<user>`: 각 group에 이름을 준다.
- re.search: 첫번째 위치를 반환한다.
- re.finditer: 각 iteration에 하나의 위치를 반환한다. memory efficient.
- 모든 예제를 써보는 것을 권장한다.
- re.sub: replace 용임. regular expression이 group과 함께 주어지면 그걸 대체한다. `\1`,`\2`,`\3`를 이용해 group 값을 다시 활용할 수 있다.
- vectorized extraction: df.str.extract를 이용해 모든 데이터에 regex를 적용할 수 있음.
- look-ahead/look-behind
	- 직전 값, 직후 값이 pattern과 같아야 함.
	- 그런데, 그게 reg에 포함되지는 않음. 하나의 조건문임.
	- `(?=X)`와 `(?<=X)`임.
	- pattern matching에 사용한다.
- verbose flag: regex compile할 때, regex의 whitespace, `#comments`를 제외해준다. (긴 regex 만들 때 주석을 달거나 줄바꿈을 할 수 있음)
- context-sensitive grammar: $a^nb^n$ 같은거. pushdown automata로 다뤄야 한다.
