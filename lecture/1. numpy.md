- NOTE: For an unclear sementic -> check the presentation slices.
### 1-1. Importance of an (n-dim) array
- Compare to lists, dictionaries, hash tables, and so on, what is the advantage of an array??
- A key-value dictionary where key is an array index.
- O(1) lookup, the storage itself is contiguous 1-dim.
- Mapping between n-dim to 1-dim should be maintained. -> Done by a space filling curve.
	- In C, row major order is the curve which performs space filling.
- ex) `Array[1][2] = (3+2) * sizeof(type)`
### 1-2. Creating an arrays
- There are so many ways in numpy to creating an array:
	1. Convert a python list to a numpy list.
	2. An array of constant values. (zeros, ones, ...)
	3. An array with monotonic (increasing or decreasing) sequence. (numpy arange $\approx$ python range(), linspace)
	4. An array with random sequence or matrices. (random sampling)
	5. Special matrix (diagonal)
	6. ...
- Concrete memory realization
	- `&array[i+1][j] - &array[i][j]` <- stride. (간격)
	- the stride differ in row, column(for integer array with size `[5][2]`, row stride is `5*4`, column stride is `1*4`) -> Implement a standard basis vector $e_k$ to step along axis.
	- bite strides = (20, 4)
	- Base address : b (`&array[0][0]`) -> `&array[i][j] = b + 20*i + 4*j` (C 컴파일러가 이러한 방식을 사용한다)
### 1-3. Array indexing (slicing)
- Basic slicing notation: `start:stop:step`. open ended(stop is not contained in the result)
- n-dim slicing by `[a1:b1:c1, ..., an:bn:cn]`
- ex) `array[2]`, `array[2:5]`, `array[2:7:3]`
### 1-4. Array operation
- element-wise op (+, -, \*, /, @, np.exp, np.sqrt, np.abs, ...)
	- The binary op must need the array with same size
- pair-wise op (np.outer)
	- Even the binary op do not necessarily need two arrays to have the same size.
- reductions
### 1-5. Broadcasting Op (kind of type casting)
- operation with different shapes
- 1-dim array can repeated to match the other operands
- shapes align from the right. no data are copied just to match sizes.
- Intuition: M (s1, s2, s3), N (s1', s2') -> M+N is valid??
	- First change N in size of (1, s1', s2')
	- Check if `s3=s2'` or any of these two is 1.
	- Check if s2=s1' or any of these two is 1.
	- Any shape with size '1' can be stretched!!
- why need broadcasting? the vectorized ops are super fast. (compared to the list)
- NEED some rigorous!!
- ex) distance chicago problem: np.abs(d-d.T)
### 1-6. Stacking arrays (vstack vs hstack)
### 1-7. Sorting & Searching
