### 2-1. Introduction
- relational data model vs pandas.
	- relational model: key is given for each table. Key is a set of attributes that uniquely identify tuples in the table(relation). For each column, there is no order. But if we attach the key column to the column, we can identify the column values.
	- labeled array model: order is meaningful.
- tabular data: have rows, columns.
		| Animal (key) | Legs |
		| ------------ | ---- |
		| cat | 4 |
		| penguin | 2 |
		| dog | 4 |
	- SQL: data by key: `SELECT legs ... WHERE Animal="Dog";`
	- Pandas: data by position.
1. Data Model: Labeled array model vs relational model
2. Underlined Algebra: (No known name) vs relational algebra
	- algebra: $(D, O)$ where D: set of data, O: set of operations
		- In relational model, D: set of table. O: {Selection, Projection, Cartesian, Set union, Set difference}
		- In pandas, $D = (S, D')$ where S: set of series, D': set of data frames, $O_S$: ==a set of operation over series==. <-- Today Interests.
3. Query Language: (No standard language) vs SQL
### 2-2. Pandas Data Structures
- Series: 1-dim labeled array
- DataFrame: 2-dim tabular array
- Index: sequence of row/column labels
- Pandas Semantics:
	- bag semantics: do not remove duplicate unless specifies. -> basic semantic for pandas.
	- set semantics: unique data.
### 2-3. Handling window function
- disjoint window: slide by k, where k: size of window. no overlap.
- sliding window: slide by 1.
### 2-4. DataFrame
- For each table (dataframe), one needs to define its schema
	- A sequence of column name and its types.
- label, position selection(loc, iloc)은 잘 쓰이지 않는다.
### 2-5. CRUD
- C: create
- R: read
- U: update
- D: delete
- query: super set of read
### 2-6. ERA
- extended relational algebra
	- selection ($\sigma_\theta(R)$)
	- projection ($\pi$): 컬럼 중 몇 개만 선택.
	- cartesian product: ($\times$)
	- set union: $\cup$
	- set difference: $-$
		- $A \cap B = A - (A - B)$이기 때문에 필요가 없어서 제외되었다.
- join(inner-join, outer-join, semi-join, anti-join)
- grouping/aggregating ($\gamma_{G;f_1(A_1) \to B_1, \cdots}(R)$): 원소를 뭉쳐서 하나의 group이라고 침. 그런데, 이것만 하면 하나의 group 안에 여러 개의 row가 있기 때문에 dataframe이 못 됨. 그래서, 합치는 방법도 명시해서, 하나의 row로 줄여야 함.
	- grouping column을 하나의 column으로 취급하려면 index를 초기화해야 한다.
- division ($R \div S$): $Schema(R \div S) = Schema(R) - Schema(S)$. S의 모든 원소를 갖는 R만 출력한다. (몫만 취하고, 일부 원소만 갖는 것들은 나머지로서 없어진다)
	- $R \div S \equiv \pi_A(R)-\pi_A(\pi_A(R)\times S - R)$
- sorting ($\tau_{A_1^{\uparrow/\downarrow},\cdots}(R)$): 각 기준에 따라 정렬한다.
- generalized projection ($\pi_{e_1 \to B_1, \cdots, e_k \to B_k}(R)$): compute value based on columns. 새로운 column을 추가한다. 그렇기 때문에 generalized가 붙음.
- pivoting ($\text{PIVOT}_{rows, cols; f(A)}(R)$)
- rename ($\rho_{A \to A'}(R)$): attribute 이름을 변경한다.
- duplicate elimination ($\delta(R)$): 중복되는 tuple을 삭제.
	- (이걸 다 알아야 한다.)
### 2-7. Join
- Inner Join
	- $\theta$-join (most general): $\sigma_\theta (R \times S) \equiv R \Join_\theta S$
	- equi-join (most popular): $R \Join_A S$. join all elements such that $R.A = S.A$ -> R과 S에서 가져와서 element-wise하게 합치기 때문에 column 개수가 늘어남. 모든 조합이 만들어짐.
	- natural-join: $R \Join S$. common column으로 알아서 equi-join을 수행.
- Outer Join: 하나의 column을 기준으로 합침.
	- left outer: 왼쪽 column을 기반으로 오른쪽을 추가. 오른쪽에 없는 행도 있음.
	- full outer: 두 컬럼을 전부 합침.
	- right outer: left outer 반대.
- 공통되는 키가 없는 경우에도 primary key를 정해서 그걸 기준으로 합칠 수 있다.
### 2-8. GroupBy
- `df.groupby(['A','B'])`를 통해 만들 수 있다. `DataFrameGroupBy`를 반환한다.
	- 이 타입은 여러 개의 dataframe을 갖고 있는 객체로서 하나의 group이 하나의 dataframe이 된다고 유추해볼 수 있다.
- `df.groupby("A")["B"]`는 SeriesGroupBy를 출력한다. 즉, Series를 출력한다.
### 2-9. Extra
- Exploratory Data Analysis (EDA): statistics + visualization
